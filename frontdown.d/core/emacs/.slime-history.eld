;; -*- coding: utf-8-unix -*-
;; History for SLIME REPL. Automatically written.
;; Edit only if you know what you're doing
("(glut:terminate)" "(array-size triangle-attributes)" "(gl-size triangle-attributes)" "(gl-array-size  triangle-attributes)
" "triangle-attributes
" "(gl-array-size  triangle-attributes
		     )" "(gl-array-size  triangle-attributes 'size)" "(slot-value  triangle-attributes 'size)" "(get-size triangle-attributes)" "triangle-attributes" "(sizeof triangle-attributes)" "(size triangle-attributes)" "(iter (for x in-sequence '(1 2 3))
	   (print x))" "(print f)" "f" "(setf (glaref f 0) 0.0)" "(setf (glaref f 0) 0)" "(setf f (gl::make-gl-array :pointer g :type :float :size 4))" "(setf f (gl::make-gl-array :pointer g))" "(gl::make-gl-array :pointer g)" "(gl::make-gl-array)" "(make-gl-array)" "(setf (:pointer f) g)" "#S(gl-array :pointer g)" "#S(gl-array )" "g" "(setf (slot-value f :pointer) g)" "(setf (slot-value f 'pointer) g)" "(setf (pointer f) g)" "(setf g (cffi:foreign-alloc :float :count 3))" "(setf (glaref f 0) 3.0)" "(setf (glaref f 0) 3)" "(setf f (gl:make-null-gl-array :float))" "(gl:make-null-gl-array :float)" "(gl:make-null-gl-array)" "(make-instance 'gl-array)" "(eofp f)" "(read-line f)" "(setf f (open \"fs.glsl\")
	   )" "0" "(MyWindow)" "(in-package :glf)" "gl-version" "(gl-version)" "(delete-package :glf)" "(glfw:terminate)" "glfw:terminate()" "gl::version" "(gl::version
      )" "(gl:get-program-info-log (program *vao*)
			      )" "(quicklisp:system-apropos \"opengl\")" "(dump-stream-into-string shit)" "(setf shit (open \"fs.glsl\"))" "(close shit)" "(read-line shit)" "(eofp shit)" "shit" "(defparameter shit shit)" "(strcatf shit \"hello there!\" \" Sir!\")" "(setf shit \"\")" "(strcat \"derp\" \"hello there!\")" "(strcat \"derp\" \"hello there!\"))" "('(strcat str \"hello there!\"))" "(macroexpand-1 '(strcat str \"hello there!\"))" "(require 'cl-opengl)" "(glfw:destroy-window *window*)" "(glfw:destroy-window)" "(glfw:create-window :width 100 :height 100 :title \"shit\")" "(glfw:initialize)" "(glfw3:window)" "(require 'cl-glfw3)" "(require 'glfw3)" "(glfw:create-window :width 1024 :height 768 :title \"shit\")" "(create-window :width 1024 :height 768 :title \"shit\")" "(glfw:create-window :title \"shit\")" "(glfw:create-window :title :shit)" "(ql:system-list)" "(ql:quickload 'cl-glew)" "(require 'cl-glwf)" "(require 'cl-glwf3)" "(ql:quickload 'cl-glfw3 :verbose nil)" "(ql:quickload 'cl-glfw3 :verbose t)" "(ql:quickload 'cl-glfw3 t)" "(ql:quickload 'cl-glfw3)" "(ql:quickload 'cl-glwf3)" "(ql:quickload 'cl-glfw)" "(exit)" "(ql:quickload 'cl-opengl-glfw3.3)" "(ql:quickload 'glwf)" "(ql:quickload 'cl-glwf)" "(ql:quickload cl-glwf)" "(rb-hello)" "ls" "(eval (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (mul x y)))))" "(eval (parse '(progn 
		   (defun mul (x y) (* x y)) 
		   (let ((x 0) (y 12)) 
		     (mul x y)))))" "(in-package :ag)" " (eval (parse '(progn 
		    (defun mul (x y) 
		      (* x y)) 
		    (let ((x 0) (y 4)) 
		      (let ((x 2)) 
			(set! x 3)
			(if (xor false true)
			    (mul x y)
			    (/ x y)))))))
" " (eval (parse '(progn 
		    (defun mul (x y) 
		      (+ x y)
		      (* x y)) 
		    (let ((x 0) (y 4)) 
		      (let ((x 2)) 
			(set! x 3)
			(if (xor false true)
			    (mul x y)
			    (/ x y)))))))
" " (eval (parse '(progn 
		    (defun mul (x y) 
		      (+ x y)
		      (* x y)) 
		    (let ((x 0) (y 4)) 
		      (let ((x 2)) 
			(set! x 3)
			(if (xor false false)
			    (mul x y)
			    (/ x y)))))))
" " (eval (parse '(progn 
		    (defun mul (x y) 
		      (* x y)) 
		    (let ((x 0) (y 4)) 
		      (let ((x 2)) 
			(set! x 3)
			(if (xor false false)
			    (mul x y)
			    (/ x y)))))))
" " " " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (xor false false)
		      (mul x y)
		      (/ x y)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (xor true false)
		      (mul x y)
		      (/ x y)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (xor true true)
		      (mul x y)
		      (/ x y)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (xor true)
		      (mul x y)
		      (/ x y)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (or true)
		      (mul x y)
		      (/ x y)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (or false)
		      (mul x y)
		      (/ x y)))))))
" "(delete-package :ag)" "(in-package :wl)" "(reduce #'+ '(3))" "(reduce #'+ '(3 4 5))" "(reduce #'and '(t nil nil t))" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (or false)
		      (mul x y)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (or true)
		      (mul x y)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (or t)
		      (mul x y)))))))
" "*bindings*" "(setf (locals *bindings*) nil)" "(eval (parse '(or t)))" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (or (< x 1) t)
		      (mul x y)))))))
" "(consp ())" "(consp nil)" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (or (< x 1) nil)
		      (mul x y)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (or (> x 1) nil)
		      (mul x y)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (or (> x 1) t)
		      (mul x y)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (not (> x 1))
		      (mul x y)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (not (< x 1))
		      (mul x y)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (and (< x 1) t)
		      (mul x y)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (xor (< x 1) t)
		      (mul x y)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (< x 1)
 		      (mul x y)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (> x 1)
 		      (mul x y)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (> x 1)
 		      (mul y x)))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 4)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (> x 1)
(print 		      (mul x y))))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 12)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (> x 1)
(print 		      (mul x y))))))))
" " (eval (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 12)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (> x 1)
		      (mul x y)))))))
" " (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 12)) 
		(let ((x 2)) 
		  (set! x 3)
		  (if (> x 1)
		      (mul x y))))))
" " (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 12)) 
		(let ((x 2)) 
		  (set! x 2)
		  (if (> x 1)
		      (mul x y))))))
" " (parse '(progn 
	      (defun mul (x y) 
		(* x y)) 
	      (let ((x 0) (y 12)) 
		(let ((x 2)) 
		  (set! x 2)
		  (if (> x 1)
		      (mul x y)))))))
" " (eval (parse '(progn 
		    (defun mul (x y) 
		      (* x y)) 
		    (let ((x 0) (y 12)) 
		      (let ((x 2)) 
			(set! x 2)
			(if (> x 1)
			    (mul x y)))))))
" "(> 3 1)" "#'>" " (eval (parse '(progn 
		    (defun mul (x y) 
		      (* x y)) 
		    (let ((x 0) (y 12)) 
		      (let ((x 2)) 
			(set! x 2)
			(if (> x 1)
			    (print (mul x y))))))))
" " (eval (parse '(progn 
		    (defun mul (x y) 
		      (* x y)) 
		    (let ((x 0) (y 12)) 
		      (let ((x 2)) 
			(set! x 2)
			(if (< x 1)
			    (print (mul x y)))
		      (print (mul x y)))))))" " (eval (parse '(progn 
		    (defun mul (x y) 
		      (* x y)) 
		    (let ((x 0) (y 12)) 
		      (let ((x 2)) 
			(set! x 2)
			(if (> x 1)
			    (print (mul x y)))
		      (print (mul x y)))))))" "#'not" "(not 'x)" "#'or" " (eval (parse '(progn 
		    (defun mul (x y) 
		      (* x y)) 
		    (let ((x 0) (y 12)) 
		      (let ((x 2)) 
			(set! x 2) 
			(print (mul x y))) 
		      (print (mul x y))))))" "(list-values (globals *bindings*))" "(setf (locals *bindings) nil)" " (eval (parse '(progn 
		    (defun mul (x y) 
		      (* x y)) 
		    (let ((x 0) (y 12)) 
		      (let ((x 2)) 
			(set! x 0) 
			(print (mul x y))) 
		      (print (mul x y))))))" " (eval (parse '(progn 
		    (defun mul (x y) 
		      (* x y)) 
		    (let ((x 0) (y 12)) 
		      (let ((x 2)) 
			(set! x 1) 
			(print (mul x y))) 
		      (print (mul x y))))))" " (eval (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (let ((x 2)) (set! x 1) (print (mul x y))) (print (mul x y))))))" " (eval (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (let ((x 2)) (set! x 1) (print (mul x y)))) (print (mul x y)))))" " (eval (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (set! x 1) (print (mul x y))))))" " (eval (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (set! x 1 (print (mul x y)))))))" " (eval (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (while (mul x y) (print (mul x y)))))))" " (eval (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (while 'true (print (mul x y)))))))" " (eval (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (while nil (print (mul x y)))))))" " (eval (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (while 1 (print (mul x y)))))))" " (eval (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (while t (print (mul x y)))))))" " (eval (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (print (mul x y))))))" " (eval (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (mul x y)))))" "(untrace eval
	     )" "(parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (mul x y))))" "(trace eval)" " (eval (car (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (mul x y))))))" "#.(eval (eval (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (mul x y))))))" "(eval (eval (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (mul x y))))))" "#.(eval (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (mul x y)))))" "(eval (parse '(* 3 5)))" "(eval (parse '(* x y)))" "(eval (parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (print (mul x y))))))" "(parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (print (mul x y)))))" "(parse '(progn (defun mul (x y) (* x y)) (let ((x 0) (y 12)) (print (mul x y))))))" "(parse '(set! x 3))" "(setf (elt *bindings* 'x) 3)" "(setf (elt *bindings 'x) 3)" "*functions*" "(elt *bindings* 'y)" "(elt *bindings* 'x)" "(trace *bindings*
	   )" "(iter (for (k v) in-hashtable (contents (car (locals *bindings*)))) (cl:print (list k v)))" "(iter (for (k v) in-hashtable (contents (car (locals *bindings*)))) (cl:print '(k v)))" "(iter (for (k v) in-hashtable (contents (car (locals *bindings*)))) (cl:print k v))" "(contents (car (locals *bindings*)))" "(car (locals *bindings*))" "(car (contents *bindings*))" "(eval (Call :name 'plus :arguments '(3 5)))" "(eval (Defun :name 'plus :lambda-list (Lambda-List :mandatory '(x y)) :body (Progn :body (list (Call :name '+ :arguments (list (Variable 'x) (Variable 'y)))))))" "(eval (Defun :name 'plus :lambda-list (Lambda-List :mandatory '(x y)) :body (Progn :body (list (Call :name '+ :arguments (list (Variable x) (Variable y)))))))" "(eval (Defun :name 'plus :lambda-list (Lambda-List :mandatory '(x y)) :body (Progn :body (list (Call :name '+ :arguments '((Variable x) (Variable y)))))))" "(eval (Defun :name 'plus :lambda-list (Lambda-List :mandatory '(x y)) :body (Progn :body (Call :name '+ :arguments '((Variable x) (Variable y))))))" "(eval (Defun :name 'plus :lambda-list (Lambda-List :mandatory '(x y)) :body (Progn :body '(Call :name '+ :arguments '((Variable x) (Variable y))))))" "(eval (Defun :name 'plus :lambda-list (Lambda-List :mandatory '(x y)) :body (Progn :body '(+ (Variable x) (Variable y)))))" "(eval (Defun :name 'plus :lambda-list '(Lambda-List :mandatory '(x y)) :body (Progn :body '(+ (Variable x) (Variable y)))))" "(eval (Defun :name 'plus :lambda-list '(x y) :body (Progn :body '(+ (Variable x) (Variable y)))))" "(eval (Defun :name 'plus :lambda-list '(x y) :body (Progn :body (+ x y))))" "(eval (Defun :name 'plus :lambda-list '(x y) :body (Progn :body (+ (Variable x) (Variable y)))))" "(ag::eval '(defun plus (x y) (+ x y)))" "(ag::eval '(defun 'plus (x y) (+ x y)))")